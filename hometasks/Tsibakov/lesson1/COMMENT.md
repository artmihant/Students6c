Касаемо Multi_Pendulum.ipynb.

Мне очень понравилось ваше решение визуально-эстетически (как выбранга схема раскраски и т.п). Зачет, переделывать код не надо. Тем не менее, решение небезупречно, и я бы хотел отметить несколько моментов:

1) Нотебук-форма имеет достоинства и недостатки. Достоинства: можно включить комментарий в md формате, удобная поблочная отладка, логическое разделение кода на подписанные фрагменты, очень удобно для DataScience так как позволяет опытному датасаентисту вывести и посмотреть на графики, собранные на каких-то данных, на ходу, прямо во время написания аналитического кода. Так же из достоинств можно упомянуть google colab с его многопользовательски-облачным опытом. Недостатки: затрудненность использования стандартных инструментов отладки IDE VSCode/PyCharm, проблемы с отображением анимаций в частности и отображением чего-то сложного в целом (существуют решения под это всё, но в них нужно разбираться). Учитывая, что достоинствами вы особо не пользовались, возможно, имеет смысл программировать такие штуки в py или пытаться разбить код на более мелкие блоки

2) Вы использовали явную схему Эйлера первого порядка, сильная накапливающаясяя погрешность которой становится заметна, если пытаться сделать классическую зацикленную анимацию Multiple Pendelum Wave на вашем кодоматериале (она не зацикливается, финальная амплитуда маятников видимо больше, чем начальная)

3) Однако эта погрешность как будто бы меньше, чем должно её быть (хотя всё равно велика) и может не так уж сильно броситься в глаза. Я немного поломал голову, в чем дело, думаю, возможно, в том, что в этом фрагменте:

    angular_velocities[j] += angular_acceleration * dt
    angles_history[j, i] = angles_history[j, i - 1] + angular_velocities[j] * dt

вы *сначала* увеличиваете угловую скорость, а *потом* угол, когда в классической схеме эти действия делаются *одновременно*. Ваше решение получилось похоже на усредненную схему Эйлера второго порядка. Разумеется, это работает, только если ваше уравнение суть есть x''(t) = F(x) , что в вашем случае без трения и получилось.

4) Ваше *вычисление* можно векторизовать, что даст некоторый прирост скорости и сделает его более numpyic. Вместо:

    for i in range(1, n_steps):
        for j in range(N):
            angular_acceleration = - (g / lengths[j]) * np.sin(angles_history[j, i - 1])
            
            angular_velocities[j] += angular_acceleration * dt
            angles_history[j, i] = angles_history[j, i - 1] + angular_velocities[j] * dt

можно написать:

    for i in range(1, n_steps):
        angular_acceleration = - (g / lengths) * np.sin(angles_history[:, i - 1])
        
        angular_velocities += angular_acceleration * dt
        angles_history[:, i] = angles_history[:, i - 1] + angular_velocities * dt

В данном кейсе расчет траектории идет условно-мгновенно, и выигрыш скорости несущественнен. Однако векторизация - это сверхспосбоность библиотеки, она делает процессорные  числодробительные операции существенно (в сотни раз) эффективнее, приближая вялый питоновский код к быстродействию, близкому к сишному, поэтому о ней полезно знать.


Суммируя всё вышесказанное и немного переименовав переменные мод мой вкус, я переписал ваш код так, что бы в нем были учтены все вышесказанные комментарии, (и была циклическая анимация маятника):

https://github.com/artmihant/students6c2024/blob/main/hometasks/Tsibakov/lesson1/Multi_Pendulum.py

